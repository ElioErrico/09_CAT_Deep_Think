from cat.mad_hatter.decorators import tool
from cat.log import log
from typing import Dict
import json
from cat.mad_hatter.decorators import hook

@tool(return_direct=False)
def deep_think(tool_input: str, cat):
    """
    Use this tool when you need to critically evaluate your reasoning approach or when you feel stuck.
    This tool helps you challenge your assumptions, consider alternative perspectives, and refine your strategy.
    
    Input should describe what aspect you want to reconsider, for example:
    - "Challenge my current approach to solving this problem"
    - "Find alternative perspectives on this technical issue"
    - "Re-evaluate my assumptions about the user's requirements"
    - "Consider if I'm missing important aspects"
    - "Think about edge cases I haven't considered"
    
    Use this tool proactively when:
    - You've tried multiple searches but haven't found satisfactory answers
    - The problem seems more complex than initially thought
    - You want to ensure you're not missing hidden requirements
    - You need to validate your reasoning before providing final answer
    """
    
    # Costruisce un contesto ricco con tutte le informazioni disponibili
    context_parts = []
    
    # 1. Aggiungi la richiesta corrente dell'utente
    user_message = cat.working_memory.user_message_json.text
    context_parts.append(f"## User's Current Request\n{user_message}")
    
    # 2. Aggiungi lo storico della conversazione recente
    chat_history = cat.working_memory.stringify_chat_history()
    if chat_history:
        context_parts.append(f"\n## Recent Conversation History\n{chat_history}")
    
    
    # 3. Aggiungi le memorie dichiarative rilevanti
    if hasattr(cat.working_memory, 'declarative_memories') and cat.working_memory.declarative_memories:
        declarative_context = "\n".join([
            f"- {mem[0].page_content[:200]}..." if len(mem[0].page_content) > 200 else f"- {mem[0].page_content}"
            for mem in cat.working_memory.declarative_memories[:3]
        ])
        context_parts.append(f"\n## Retrieved Documents\n{declarative_context}")
    
    # 4. Aggiungi informazioni sui tool già utilizzati
    if hasattr(cat.working_memory, 'agent_input') and hasattr(cat.working_memory.agent_input, 'tools_output'):
        tools_used = cat.working_memory.agent_input.tools_output
        if tools_used:
            context_parts.append(f"\n## Tools Already Used\n{tools_used}")
    
    # Costruisce il prompt di metacognizione
    full_context = "\n".join(context_parts)
    
    metacognitive_prompt = f"""You are performing a deep metacognitive analysis of your reasoning process.

{full_context}

## Your Reflection Task
{tool_input}

Perform a thorough metacognitive analysis by addressing these dimensions:

### 1. Current Approach Evaluation
- What strategy are you currently following?
- What assumptions have you made?
- Are these assumptions valid given the context?

### 2. Alternative Perspectives
- What other angles could you consider?
- Are there different interpretations of the user's request?
- What perspectives might you be missing?

### 3. Hidden Requirements Analysis
- Are there implicit needs not explicitly stated?
- What edge cases should be considered?
- What constraints might affect the solution?

### 4. Strategy Refinement
- Should you continue with the current approach or pivot?
- What additional information would be most valuable?
- Which tools or resources haven't been fully utilized?

### 5. Quality Assurance
- Have you addressed all aspects of the question?
- Is your reasoning complete and coherent?
- What potential gaps remain?

Provide a structured reflection that includes:
1. Critical assessment of current approach
2. At least 2 alternative perspectives to consider
3. Specific recommendations for next steps
4. Any warnings about potential pitfalls

Be honest and critical - the goal is to improve reasoning, not to justify existing approaches."""

    try:
        # Usa l'LLM per generare la riflessione metacognitiva
        reflection = cat.llm(metacognitive_prompt)
        
        # Log per debugging
        log.info(f"Deep Think Reflection Generated:\n{reflection[:500]}...")
        
        # Prepara l'output strutturato
        output = f"""## Metacognitive Reflection

{reflection}

---
*This reflection was generated by the deep_think tool to help refine the reasoning approach.*
"""
        
        # Salva la riflessione nella working memory per riferimento futuro
        if not hasattr(cat.working_memory, 'metacognitive_reflections'):
            cat.working_memory.metacognitive_reflections = []
        
        cat.working_memory.metacognitive_reflections.append({
            'input': tool_input,
            'reflection': reflection,
            'context': full_context[:1000]  # Salva solo i primi 1000 char del contesto
        })
        
        return output
        
    except Exception as e:
        log.error(f"Error in deep_think tool: {e}")
        return f"Deep thinking process encountered an error: {str(e)}. Continuing with current approach."


@hook  # default priority = 1 
def before_cat_reads_message(user_message_json, cat):
    """
    Hook che aggiunge un prompt di pianificazione a tutti i messaggi quando il tool è abilitato.
    Questo garantisce che la prima azione dell'agente sia sempre la pianificazione.
    """
    settings = cat.mad_hatter.get_plugin().load_settings()
    tool_key = settings["tool_name"]    
    
    # ---- Guard: abilita/disabilita tool per utente; fallback=False ----
    try:
        with open("cat/static/tools_status.json", "r", encoding="utf-8") as f:
            ts = json.load(f) or {}
    except Exception:
        ts = {}

    uid = str(getattr(cat, "user_id", "") or "")
    enabled = bool(
        ts.get("tools", {})
          .get(tool_key, {})
          .get("user_id_tool_status", {})
          .get(uid, False)
    )
    # cat.send_ws_message(f"Tool {tool_key} enabled for user {uid}","chat")
    if not enabled:
        # cat.send_ws_message(f"Tool {tool_key} not enabled for user {uid}","chat")
        return user_message_json

    # Prompt di pianificazione che verrà aggiunto a tutte le richieste
    planning_phase_prompt = """\n - Devi usare il tool 'deep_think' almeno 1 volta. Usalo quando pensi che potrebbe aiutarti di più nella tua analisi."""

    user_message_json["text"] = user_message_json["text"] + planning_phase_prompt
    return user_message_json

